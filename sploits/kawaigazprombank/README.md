# ctfcup-2022 | Stage3 Part1 | KawaiGazPromBank

Разбор сервиса KawaiGazPromBank с финала Кубка CTF России 2022.

## Описание

Сервис представляет собой несколько Solidity контрактов для приватного PoA блокчейна, не поддерживающего операции чтения содержимого контракта, за исключением вызова `eth_call`. Каждый контракт представляет собой тот или иной банковский сервис.

### 1. Box

Сервис - банковская ячейка, позволяющая хранить приватные данные. Может быть открыта только владельцем или человеком, знающим от нее секретный ключ. Контракт является NFT (non-fungible token) и реализует расширенный интерфейс IERC721.

### 2. Coin

Сервис - монета, за которую можно покупать и продавать вещи в магазине предметов. Приватная информация стоит большое количество денег, которое не получится набрать без уязвимости. Контракт является fungible token и реализует расширенный интерфейс IERC20.

### 3. Card

Сервис - менеджер банковских карт, позволяющий как пополнять свой баланс, так и снимать его. Также можно делать подарки, тогда на карте получения появится запись об этом. Контракт полностью реализован на Yul - IR для Solidity.

## Флаги

### 1. Box

Проверяющая система кладет флаг в словарь datas.

### 2. Coin

Проверяющая система кладет флаг в поле content для item.

### 3. Card

Проверяющая система кладет флаг в параметр key при создании подарка.

## Уязвимости

Сервис содержит три уязвимости.

### 1. Box

Функция `exterminateBox` [Box.sol](../../services/kawaigazprombank/contracts/box/Box.sol#L75) делает `delete owners[_tokenId];` перед вызовом колбека `IBoxOwner.boxExterminated`, однако не очищает `datas[_tokenId]`, что можно использовать для того, чтобы в `boxExterminated` вызвать функцию `mint` с удаляемым `_tokenId`, таким образом выставив `owners` в свой аккаунт. Так как `materializeBox` сначала вызывает колбек `IBoxOwner.boxMaterialized` и только потом переписывает `datas[_tokenId]`, можно прочитать содержимое бокса в `boxMaterialized`.

### 2. Coin

В функции `setShareholder` [Coin.sol](../../services/kawaigazprombank/contracts/coin/Coin.sol#L80) содержит ошибку и проверяет равенство `msg.sender` переданному параметру `_shareholder` вместо `shareholder`, что позволяет стать shareholder, просто передав в эту функцию свой адрес. После чего можно будет вызвать `getCoins`, передав ему большое количество монет и купить нужный предмет.

### 3. Card

Функция создания подарка [Card.sol](../../services/kawaigazprombank/contracts/card/Card.sol#L136) сохраняет ключ в память, а затем читает его в функции `sign` для создания ключа [Card.sol](../../services/kawaigazprombank/contracts/card/Card.sol#L185). В Solidity версии 0.8.14 существует [CVE](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/), приводящее к исчезновению некоторых операций записи при включенной оптимизации. В данном случае пропадает установка указателя памяти 0x40, что приводит к переписыванию ключа по адресу 0x80 на первый аргумент функции `sign`, так как он лежит в memory. Первый аргумент - структура `Gift`, нас интересует ее первое поле - `to`. При применении операции xor данное поле обнулится самим собой, таким образом функция `sign` вернет xor флага и хеша от блока транзакции, который можно перебрать и расшифровать флаг.

Пример полной реализации атак можно увидеть в
[Exploit.sol](Exploit.sol).

#### Исправление уязвимости.

### 1. Box

Для исправления уязвимости можно добавить проверку на reentrancy в функции `exterminateBox` и `materializeBox`.

[Пример исправления.](box.patch)

### 2. Coin

Для исправления уязвимости необходимо заменить проверку `require(msg.sender == _shareholder);` на `require(msg.sender == shareholder);`.

[Пример исправления.](coin.patch)

### 3. Card

Для исправления уязвимости можно использовать поле `gift.key`, а не сохранять ключ в память.

[Пример исправления.](card.patch)
